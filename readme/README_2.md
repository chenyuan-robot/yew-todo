## 为什么链式调用 (map、filter、chain) 都需要 iter？

链式调用中的 `map`、`filter`、`chain` 等方法都需要使用 `.iter()`，是因为这些方法的本质是对集合中的元素进行操作，而 `iter()` 提供了集合元素的迭代器。具体来说，以下几点可以解释为什么要使用 `iter()`：

### 1. **迭代器的基本概念**

`iter()` 返回一个不可变的迭代器，它允许我们以惰性方式访问集合中的元素。`map`、`filter`、`chain` 等方法都是基于迭代器设计的，它们会返回新的迭代器，这个新的迭代器会在元素上进行某些操作或者组合。

- `map`：将集合中的每个元素映射到一个新值。
- `filter`：筛选集合中的元素，只保留满足某个条件的元素。
- `chain`：连接两个迭代器，将两个集合的数据拼接成一个新的迭代器。

这些操作都是惰性求值的，它们不会立即处理数据，而是返回一个新的迭代器，只有在调用 `.collect()` 或者消耗迭代器时，才会对元素进行处理。

### 2. **为什么必须使用 `iter()`**

在 Rust 中，集合如 `Vec`、`HashMap` 等通常并不直接实现 `map`、`filter`、`chain` 等方法。这些方法属于迭代器 (`Iterator`) 类型的扩展，而集合本身提供的只有基本的访问和操作方法。

- 例如，`Vec` 类型并没有直接实现 `map` 方法，但它实现了 `IntoIterator`，这意味着我们可以通过 `iter()` 方法将 `Vec` 转换为一个迭代器，从而调用 `map`、`filter` 等方法。
- `.iter()` 将 `Vec<T>` 转换为一个不可变的迭代器（`std::slice::Iter`），然后可以链式调用各种操作。

### 3. **具体例子**

假设你有一个 `Vec<T>`，想要对每个元素进行操作，或者对多个集合进行连接操作，必须通过 `iter()` 来得到迭代器，之后你可以使用链式调用的方式进行操作：

#### 示例：`map` 和 `filter`

```rust
let numbers = vec![1, 2, 3, 4, 5];

// 使用 `iter()` 获取迭代器，然后使用 `map` 和 `filter` 进行链式操作
let result: Vec<i32> = numbers.iter()
    .map(|&x| x * 2)  // 对每个元素乘以 2
    .filter(|&x| x > 5) // 只保留大于 5 的元素
    .collect();

println!("{:?}", result); // 输出 [6, 8, 10]
```

在这里，`numbers.iter()` 返回了一个迭代器，之后对这个迭代器进行 `map` 和 `filter` 操作。每个操作都会返回一个新的迭代器，直到最终调用 `.collect()`，将迭代器中的数据收集成一个 `Vec<i32>`。

#### 示例：`chain`

```rust
let vec1 = vec![1, 2, 3];
let vec2 = vec![4, 5, 6];

let combined: Vec<i32> = vec1.iter()
    .chain(vec2.iter())  // 将 vec1 和 vec2 连接在一起
    .collect();

println!("{:?}", combined); // 输出 [1, 2, 3, 4, 5, 6]
```

在这个例子中，`chain` 用于将两个迭代器（`vec1.iter()` 和 `vec2.iter()`）连接起来，形成一个新的迭代器。它不会立即执行合并操作，直到最终收集所有元素。

### 4. **为什么不直接在 `Vec` 上调用 `map` 等方法**

`Vec<T>` 实际上是一个集合容器，它本身并不直接实现迭代器的方法。如果没有 `.iter()`，Rust 无法将 `Vec` 转换为迭代器，从而无法链式调用 `map`、`filter` 等方法。这是因为这些方法是迭代器的扩展，Rust 的迭代器模式要求在处理集合元素时，要首先将集合转换成迭代器。

### 总结

- `iter()` 是将集合转换为一个迭代器，迭代器可以按需逐个元素地进行操作。
- `map`、`filter`、`chain` 等方法是迭代器提供的功能，它们不会直接操作集合，而是基于迭代器对集合中的元素进行处理。
- 这些方法的链式调用依赖于迭代器，集合本身并没有这些方法的实现，因此需要先通过 `.iter()` 获取一个迭代器。

所以，`.iter()` 并不是因为 `Rc` 或某种特定类型，而是所有集合类型（如 `Vec<T>`）都通过 `iter()` 转换为迭代器，才能使用链式方法操作元素。
